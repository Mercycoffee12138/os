# lab1 最小执行内核

## 一、实验内容

本章你将学到：

- 使用 链接脚本 描述内存布局
- 进行 交叉编译 生成可执行文件，进而生成内核镜像
- 使用 OpenSBI 作为 bootloader 加载内核镜像，并使用 Qemu 进行模拟
- 使用 OpenSBI 提供的服务，在屏幕上格式化打印字符串用于以后调试、

## 二、具体实验

### 练习1：理解内核启动中的程序入口操作

#### 练习内容

阅读 $kern/init/entry.S$内容代码，结合操作系统内核启动流程，说明指令 $la$ $sp$, $bootstacktop$ 完成了什么操作，目的是什么？ $tail$ $kern_init$ 完成了什么操作，目的是什么？

#### 具体实验过程

因为需要结合操作系统内核启动流程，所以我们首先需要明确的是操作系统内核启动流程是什么：

1. **硬件初始化**: CPU上电后，从固定地址开始执行
2. **引导加载器(Bootloader)**: 将内核加载到内存地址 `0x80200000`（在$kernel.ld$中定义的`BASE_ADDRESS`）
3. **内核入口点**: 跳转到 `kern_entry` 标签开始执行内核代码
4. **栈初始化**: 设置内核栈
5. **内核初始化**: 调用 `kern_init` 函数

#### (1)$la$ $sp$ ,$bootstacktop$

明确了流程之后我们需要首先解读指令$la$ $sp$ ,$bootstacktop$

$la$的完整指令名称叫$load$ $address$，这个指令将$bootstacktop$的地址加载到了栈指针寄存器$sp$中，其中$bootstacktop$是在汇编代码末尾定义的标签，指向栈顶位置。这段指令的目的是：初始化内核栈: 为内核建立一个可用的栈空间。其中栈空间的大小: 根据 $memlayout.h$ 定义，栈大小为 $KSTACKSIZE = KSTACKPAGE * PGSIZE = 2 * 4096 = 8KB$，同时栈增长方向: 在RISC-V架构中，栈是向下增长的，所以 `sp` 指向栈顶（高地址）

总结来说整个栈的布局如下：

```
高地址 → bootstacktop  ← sp指向这里
        |            |
        |   8KB栈    |
        |   空间      |
低地址 → bootstack
```

#### (2)$tail$ $kern\_init$

$tail$ 是一个伪指令，相当于尾调用优化的跳转,实际上等价于 $jal$ $x0$, $kern\_init$，即跳转到 $kern\_init$ 函数但不保存返回地址。这个操作的目的有三个：

1. 转移控制权: 将程序控制权转移给C语言编写的 `kern_init` 函数
2. 节省栈空间: 使用尾调用避免在栈上保存返回地址，因为这是一个不会返回的调用
3. 开始C代码执行: 从汇编代码过渡到C代码，开始真正的内核初始化

我们了解完$tail$ $kern\_init$这个指令的意思之后，我们来看看$kern\_init$函数，我们使用$grep$命令之后看到了在$init.c$文件里面的$kern\_init$函数的定义：

```c
int kern_init(void) {
    extern char edata[], end[];
    memset(edata, 0, end - edata);  // 清零BSS段
    
    const char *message = "(THU.CST) os is loading ...\n";
    cprintf("%s\n\n", message);    // 输出启动信息
    while (1);                      // 无限循环（目前只是演示）
}
```

为了搞清楚这个函数的具体作用，我们于是往上的结构去寻找，找到了$kern\_entry$再继续向上寻找，找到了$kernel.id$脚本，最终获得了整个流程：

1. CPU启动 → 固定地址加载内核 → 跳到链接脚本指定的入口点（`kern_entry`）
2. `kern_entry`（汇编） → 初始化栈等 → 跳到`kern_init`（C语言）
3. `kern_init`（C语言） → 进行内核初始化



### 练习2: 使用GDB验证启动流程

首先我们使用$make$指令对项目进行构建：

![001](D:\Desktop\OS实验\lab1\001.png)

然后我们在当前页面下输入$make$ $debug$，进入调试模式，再新开一个页面，输入$make$ $gbd$，进入$GBD$调试工具内部：

![002](D:\Desktop\OS实验\lab1\002.png)

我们可以看到$GDB$已经成功连接到$QEMU$，并且我们可以看到$CPU$确实停在了$0x1000$地址，这正是$RISC-V$的复位地址。现在开始调试$CPU$复位地址的执行：

我们首先执行以下操作来查看当前PC处的指令

```
(gdb) x/10i $pc
```

![pc处指令](D:\Desktop\OS实验\lab1\pc处指令.png)



接着我们使用以下语句来查看寄存器的状态：

```
(gdb)  (gdb) info registers
```

接下来我们查看0x1000地址处的内存状态：

```
(gdb) x/10x 0x1000
```

![寄存器和内存内容](D:\Desktop\OS实验\lab1\寄存器和内存内容.png)

我们从寄存器和内容状态可以看出所有 RISC-V 寄存器几乎都是 `0x0`,这表明系统刚刚启动或处于初始化状态:

pc (程序计数器): `0x1000` - 这是当前执行的指令地址；其他寄存器(ra, sp, gp, tp, 通用寄存器等)都是 0

###### 内存内容 (`x/10x 0x1000`)

从地址 `0x1000` 开始的内存内容显示了 RISC-V 指令序列:

```
0x1000: 0x00000297  →  auipc t0, 0x0
0x1004: 0x02028593  →  addi  a1, t0, 0x20
0x1008: 0xf1402573  →  csrr  a0, mhartid
0x100c: 0x0182b283  →  ld    t0, 24(t0)
0x1010: 0x00028067  →  jr    t0
0x1014: 0x00000000  →  (数据)
0x1018: 0x80000000  →  (数据,可能是跳转目标地址)
0x101c: 0x00000000  →  (数据)
0x1020: 0xedfe0dd0  →  (可能是设备树或其他数据结构的魔数)
0x1024: 0x260d0000  →  (数据)
```

这是 QEMU RISC-V 的启动代码(bootloader),通常位于地址 `0x1000`:

`auipc t0, 0x0` - 将当前 PC 值加载到 t0 寄存器

`addi a1, t0, 0x20` - 计算偏移地址(可能指向设备树地址)

`csrr a0, mhartid` - 读取硬件线程 ID 到 a0

`ld t0, 24(t0)` - 从内存加载跳转目标地址(`0x80000000`)

`jr t0` - 跳转到 `0x80000000`,这通常是你的 ucore 内核入口地址

地址 `0x1018` 处的 `0x80000000` 就是内核的加载地址,这是 RISC-V 约定的内核起始地址。



现在我们从复位地址0x1000处输入`x/10i $pc`：

##### **0x1000 处的 5 条关键指令:**

| 地址     | 指令              | 功能说明猜测                               |
| -------- | ----------------- | ------------------------------------------ |
| `0x1000` | `auipc t0,0x0`    | 将当前 PC (0x1000) 加载到 t0 寄存器        |
| `0x1004` | `addi a1,t0,32`   | t0 + 32 = 0x1020,存入 a1 (设备树地址)      |
| `0x1008` | `csrr a0,mhartid` | 读取硬件线程 ID 到 a0                      |
| `0x100c` | `ld t0,24(t0)`    | 从地址 0x1018 加载数据到 t0 (OpenSBI 入口) |
| `0x1010` | `jr t0`           | 跳转到 t0 (即 0x80000000)                  |

我们现在逐步进行调试对我们的猜想进行验证：

我们首先输入`si`来执行下一步指令，然后输入`info registers t0 pc`对当前状态进行查看：

![单步调试第一步](D:\Desktop\OS实验\lab1\单步调试第一步.png)

##### **观察结果:**

 `t0 = 0x1000` 表示保存了当前 PC 值, `pc = 0x1004` 表示`pc`移动到下一条指令。这条 `auipc t0,0x0` 指令成功将 PC 值加载到了 t0 寄存器!

接着我们执行

```
si
info registers a1 pc
```

![单步调试第二步](D:\Desktop\OS实验\lab1\单步调试第二步.png)

##### **观察结果:**

 `a1 = 0x1020` 表示设备树地址 被设置为`0x1000 + 32`, `pc = 0x1008` 表示pc移动到下一条指令

我们继续执行：

```
si
info registers a0 pc
```

![单步调试第三步](D:\Desktop\OS实验\lab1\单步调试第三步.png)

这条 `csrr a0,mhartid` 指令从 CSR (Control and Status Register) 读取硬件线程 ID，`a0 = 0` 表示这是第 0 号 CPU 核心，`pc` 移动到 `0x100c`

我们继续执行

```
si
info registers t0 pc
```

![单步调试第四步](D:\Desktop\OS实验\lab1\单步调试第四步.png)

这条 `ld t0,24(t0)` 指令从地址 `0x1000 + 24 = 0x1018` 读取 8 字节数据，并将读取到的值 `0x80000000` 是 OpenSBI 固件的入口地址，然后将`pc` 移动到 `0x1010` (最后一条跳转指令)

我们继续执行

```
si
info registers pc
```

![单步调试第五步](D:\Desktop\OS实验\lab1\单步调试第五步.png)

执行 `jr t0` 后,PC 从 `0x1010` 跳转到 `0x80000000`，现在 CPU 已经进入 OpenSBI 固件

现在我们要跳过 OpenSBI 的初始化过程,直接监控内核何时被加载到 `0x80200000`。

首先,查看一下 OpenSBI 入口的指令:

```
x/20i 0x80000000
```

这是 OpenSBI 固件的入口点,负责:
1. 初始化 M-mode 环境
2. 设置异常/中断处理
3. 加载内核到 0x80200000
4. 跳转到内核
