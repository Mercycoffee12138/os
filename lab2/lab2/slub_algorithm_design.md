# SLUB 物理内存管理器设计文档

## 1. 算法概述

SLUB（Simple List of Unused Blocks）是一种高效的动态内存分配算法，在Linux内核中用于对象级内存管理。本实现在 uCore 操作系统中提供了基于First-Fit算法的物理页面分配功能，并预留了完整的SLUB对象分配框架。

## 2. 设计原理

### 2.1 基本思想

- 采用First-Fit算法进行页面级分配，遍历页面数组寻找连续空闲块
- 预留完整的SLUB框架，包括CPU缓存、Slab管理和对象分配机制
- 使用静态内存池解决初始化时的元数据分配问题
- 为未来的对象级分配功能提供扩展基础

### 2.2 核心机制

**页面分配流程**：
1. 遍历所有页面寻找连续空闲块
2. 找到合适块后标记为已分配
3. 返回分配的页面指针

**释放流程**：
1. 验证页面确实已分配
2. 清除所有页面标志位
3. 重置引用计数

### 2.3 数据结构

```c
#define SLUB_NUM_SIZES      10      // Size Class数量
#define SLUB_CPU_CACHE_SIZE 16      // CPU缓存容量

// 全局分配器
struct slub_allocator {
    struct slub_cache *size_caches[SLUB_NUM_SIZES];
    struct slub_page_info *page_infos;
    size_t total_allocs, total_frees, cache_hits;
};

// CPU缓存结构（预留）
struct slub_cpu_cache {
    void **freelist;        // 空闲对象数组
    unsigned int avail;     // 当前可用数量
    unsigned int limit;     // 容量限制
};
```

## 3. 核心算法实现

### 3.1 初始化 (slub_init)

- 清零全局分配器结构
- 初始化10个size class的缓存结构
- 为CPU缓存分配静态内存空间

### 3.2 内存映射初始化 (slub_init_memmap)

- 计算页信息数组所需空间
- 在内存开始处分配页信息数组
- 初始化剩余页面为空闲状态

### 3.3 页面分配 (slub_alloc_pages)

**算法流程**：

1. 遍历所有页面，跳过已分配或块头页
2. 检查是否有n个连续空闲页
3. 找到合适块后标记为已分配
4. 返回分配的页面指针

**First-Fit搜索**：

```
页面数组：[已分配][空闲][空闲][已分配][空闲][空闲][空闲]
查找3页：           ✓                    ✓ 找到！
```

### 3.4 页面释放 (slub_free_pages)

**算法流程**：

1. 验证所有页面确实已分配
2. 清除PageReserved和PageSlab标志
3. 重置页面引用计数为0

### 3.5 辅助函数 (slub_nr_free_pages)

遍历所有页面，统计未被保留且不是块头的空闲页面数量。

## 4. 关键特性

### 4.1 内存利用率

- 内部碎片：页面级分配，最大3KB内部碎片
- 外部碎片：First-Fit算法会产生外部碎片，但实现简单

### 4.2 时间复杂度

- 分配：O(npage)，需要遍历所有页面
- 释放：O(n)，n为释放页面数
- 统计：O(npage)，遍历统计空闲页

### 4.3 空间复杂度

- 页信息数组：每页需要额外的slub_page_info结构
- 静态堆：64KB固定开销用于元数据
- Size Class缓存：10个缓存结构的存储开销

## 5. 测试用例设计

### 5.1 基本功能测试

- 单页和多页分配测试
- 地址唯一性验证
- 引用计数初始化验证
- 物理地址范围检查

### 5.2 边界条件测试

- 分配0页的处理
- 内存耗尽时的行为
- 释放未分配页面的检测

### 5.3 算法特性测试

- 连续页面分配能力
- 释放后重新分配验证
- 页面标志位正确性

### 5.4 性能测试

- 多次分配释放性能
- 大块分配性能
- 统计信息准确性

## 6. 与其他算法的比较

| 特性       | First Fit | Buddy System | SLUB PMM |
| ---------- | --------- | ------------ | -------- |
| 查找时间   | O(n)      | O(log n)     | O(n)     |
| 内部碎片   | 低        | 中等         | 低       |
| 外部碎片   | 高        | 低           | 中等     |
| 合并效率   | 低        | 高           | 无       |
| 实现复杂度 | 低        | 中等         | 低       |
| 扩展性     | 低        | 中等         | 高       |

## 7. 优化空间

### 7.1 可能的改进

1. **对象级分配**：实现真正的SLUB对象分配功能
2. **CPU缓存优化**：启用per-CPU缓存提升性能
3. **合并机制**：添加相邻空闲页面合并功能
4. **预分配优化**：为常用大小预分配页面池

### 7.2 已知限制

1. 当前仅支持页面级分配，未实现对象级功能
2. First-Fit算法效率较低，大内存时性能下降
3. 缺乏合并机制，容易产生外部碎片
4. 静态预留的数据结构占用额外内存

## 8. 总结

本SLUB PMM实现提供了：

- 完整的PMM接口兼容性，可与其他PMM无缝切换
- 基于First-Fit的页面分配机制
- 为未来SLUB对象分配预留的完整框架
- 全面的测试用例覆盖

该实现适合作为SLUB算法的第一阶段实现，在保证基础功能正确的同时，为后续的对象级分配功能奠定了坚实基础。预留的数据结构和接口设计为将来扩展为完整的SLUB分配器提供了清晰的发展路径。