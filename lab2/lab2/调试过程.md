### 终端1：启动QEMU

```
pkill -9 qemu-system-riscv64
make debug
```

### 终端2：连接ucore GDB（但先不continue）

```
make gdb
```

**在gdb中执行**：

```
# 获取地址信息
(gdb) print /x (uintptr_t)kern_init
$1 = 0xffffffffc02000d8

(gdb) print /x (uintptr_t)pmm_init
$2 = 0xffffffffc0200ff6

# 记下这两个地址
# 但是**先不执行continue**，等等看！
```

**停在这里，等待终端3的信号**

### 终端3：连接QEMU GDB并设置断点

```
# 查找QEMU进程PID
ps aux | grep qemu-system-riscv64 | grep -v grep
# 输出：lamp  3124  ...
# 记下PID：3124

# 启动GDB
sudo gdb /mnt/c/Users/13081/qemu-4.1.1/riscv64-softmmu/qemu-system-riscv64

# 在gdb中执行
(gdb) attach 3124
(gdb) handle SIGPIPE nostop noprint

# **关键：先设置断点，再continue**
(gdb) b get_physical_address
(gdb) c
```

**此时终端3执行了`c`，QEMU继续运行，等待断点触发**。

### 现在回到终端2：执行continue来触发访存

```
# 在终端2中执行continue
(gdb) continue
```

### 断点触发

**终端3会停下来**：

```
Thread X "qemu-system-ris" hit Breakpoint 1, riscv_cpu_tlb_fill 
    (cs=0x..., address=4096, size=0, access_type=MMU_INST_FETCH, 
     mmu_idx=3, probe=false, retaddr=0) 
    at .../cpu_helper.c:438
438     {
(gdb)
```

**现在两个终端都在GDB中等待命令**

从这里开始，按照我之前说的步骤在**终端3中执行**：

```
# 查看调用栈
(gdb) bt

# 单步进入get_physical_address
(gdb) step
(gdb) step
...

# 查看虚拟地址
(gdb) print /x addr
(gdb) print /x env->satp
...
```

---

# 第一部分：QEMU源码关键调用路径与分支说明

## 1.1 访存指令在QEMU中的处理流程

当uCore内核执行访存指令（如`lw`、`sw`、`jalr`等）时，QEMU模拟器需要将**虚拟地址翻译为物理地址**。整个过程涉及以下关键路径：

```
访存指令执行（如lw, sw, jalr）
    ↓
QEMU TCG后端模拟该指令
    ↓
调用 get_page_addr_code() / get_page_addr_data()
    ↓
TLB查找 tlb_fill() [accel/tcg/cputlb.c]
    ↓
TLB miss ？
    ├─ 是 → riscv_cpu_tlb_fill() [target/riscv/cpu_helper.c:438]
    │       ↓
    │       get_physical_address() [target/riscv/cpu_helper.c:158]
    │       ↓
    │       三级页表遍历循环
    │       ↓
    │       返回物理地址，写入TLB
    │
    └─ 否 → 直接返回TLB中缓存的物理地址
```

## 1.2 关键源码文件与函数

| 文件 | 函数 | 行号 | 功能 |
|------|------|------|------|
| `accel/tcg/cputlb.c` | `tlb_fill()` | 878 | TLB缺失异常处理入口 |
| `accel/tcg/cputlb.c` | `get_page_addr_code()` | 1033 | 获取指令地址的物理页 |
| `target/riscv/cpu_helper.c` | `riscv_cpu_tlb_fill()` | 438 | RISC-V的TLB缺失处理 |
| `target/riscv/cpu_helper.c` | `get_physical_address()` | 158 | 核心：执行页表遍历翻译 |
| `target/riscv/cpu_helper.c` | 三级循环 | 237 | for(i=0; i<levels; i++) |

## 1.3 关键分支说明

在 `get_physical_address()` 内部：

```c
// 第一个关键分支：是否开启分页？
if (mode == PRV_M || !riscv_feature(env, RISCV_FEATURE_MMU)) {
    *physical = addr;  // 直接映射：物理地址 = 虚拟地址
    return TRANSLATE_SUCCESS;
}

// 第二个关键分支：SATP寄存器值，决定页表模式
vm = get_field(env->satp, SATP_MODE);
switch (vm) {
    case 8:  // SV39模式（三级39位虚拟地址）
        levels = 3;
        ptidxbits = 9;
        ptesize = 8;
        break;
}

// 第三个关键分支：三级循环中，PTE有效性判断
for (i = 0; i < levels; i++, ptshift -= ptidxbits) {
    target_ulong idx = (addr >> (PGSHIFT + ptshift)) & ((1 << ptidxbits) - 1);
    target_ulong pte_addr = base + idx * ptesize;
    target_ulong pte = ldq_phys(cs->as, pte_addr);
    
    if (!(pte & PTE_V)) {
        // 无效页表项，异常
    } else if (!(pte & (PTE_R | PTE_W | PTE_X))) {
        // 指针节点，继续遍历下一层
        base = (pte >> PTE_PPN_SHIFT) << PGSHIFT;
    } else {
        // 叶子节点，找到物理页号，break
    }
}
```

---

# 第二部分：虚拟地址到物理地址翻译的实际演示

## 2.1 调试数据：第一次TLB miss翻译

当内核初始化时，访问虚拟地址 `0xffffffffc02000d8`（kern_init函数入口）时：

```
(gdb) print /x env->satp
$26 = 0x8000000000080204

(gdb) print /x addr
$27 = 0xffffffffc02000d8

(gdb) print mode
$29 = 1  // PRV_S（Supervisor模式）
```

## 2.2 分页模式识别

```
(gdb) print vm
$32 = 8  // SV39模式，三级页表
```

## 2.3 三级循环执行（第一层 i=0，L2）

循环初始值：
- `levels = 3, ptidxbits = 9, ptesize = 8`
- `ptshift = (3-1)*9 = 18`

**计算L2级索引**：
```
(gdb) print i
$33 = 0  // 第一层

(gdb) print /x idx
$36 = 0x1ff  // 从虚拟地址提取的L2 VPN
```

**计算L2级PTE物理地址**：
```
(gdb) print /x pte_addr
$35 = 0x7f  // base + 0x1ff * 8
```

**读取L2级PTE**：
```
(gdb) print /x pte
$45 = 0x62746fb4e818  // 读出的PTE内容，物理页号在高位
```

## 2.4 最终物理地址计算

由于L2级的PTE包含R权限（叶子节点），循环在i=0时结束：

```
(gdb) print /x *physical
$46 = 0x80200000  // 最终物理地址
```

**虚拟→物理映射结果**：
```
虚拟地址：0xffffffffc02000d8  →  物理地址：0x80200000
```

---

# 第三部分：页表翻译的单步调试与详细流程解释

## 3.1 三级循环的本质

RISC-V SV39分页使用三级页表，虚拟地址结构为：

```
虚拟地址（64位）
┌──────────────────────────────────────────┐
│ 高25位 │ VPN[2] │ VPN[1] │ VPN[0] │ offset │
│ 符号扩展 │ 9位   │ 9位   │ 9位   │ 12位 │
└──────────────────────────────────────────┘
            L2      L1      L0     页内
```

三级循环对应三个查表步骤：

```c
for (i = 0; i < levels; i++, ptshift -= ptidxbits) {
    // i=0: ptshift=18, 从虚拟地址[29:21]提取L2的VPN(9位)
    // i=1: ptshift=9,  从虚拟地址[20:12]提取L1的VPN(9位)
    // i=2: ptshift=0,  从虚拟地址[11:3]提取L0的VPN(9位)
    
    target_ulong idx = (addr >> (PGSHIFT + ptshift)) & ((1 << ptidxbits) - 1);
    // 提取虚拟地址的某一部分作为页表索引（0-511）
    
    target_ulong pte_addr = base + idx * ptesize;
    // 计算该层页表项在物理内存中的地址
    
    target_ulong pte = ldq_phys(cs->as, pte_addr);
    // 从物理内存读取该页表项内容（8字节）
}
```

## 3.2 两行关键操作的详细解释

### 操作一：计算PTE物理地址

```c
target_ulong pte_addr = base + idx * ptesize;
```

**含义**：
- **base**：当前层页表的物理基址
  - 初始值：`SATP[PPN] << PGSHIFT`（从SATP寄存器读出）
  - 后续值：上一层PTE中的物理页号，左移12位（乘以4096）
- **idx**：当前层的页表索引（0-511），由虚拟地址的9位VPN提取
- **ptesize**：8字节，64位
- **结果**：当前PTE在物理内存中的精确地址

### 操作二：从物理内存读取PTE

```c
target_ulong pte = ldq_phys(cs->as, pte_addr);
```

**含义**：
- **ldq_phys()**：QEMU提供的函数，用于从物理地址空间读取64位数据
- **cs->as**：当前CPU的地址空间
- **pte_addr**：上一步计算的物理地址
- **返回值 pte**：该物理地址处的8字节内容，结构为：
  - 位0：V（有效位）
  - 位1：R（可读）
  - 位2：W（可写）
  - 位3：X（可执行）
  - 位4-9：暂留位，QEMU用于A、D位等
  - 位10-63：物理页号（PPN），44位

## 3.3 调试步骤详解

按照如下步骤单步调试，观察完整的三层遍历：

```gdb
# 进入三级循环
(gdb) step  # 执行到 for (i = 0; i < levels; i++)

# ========== 第一层循环（i=0, L2） ==========
(gdb) print i
$53 = 0  // 第一层

(gdb) print /x idx
$54 = 0x1ff  // L2的VPN，从虚拟地址[29:21]提取

(gdb) step  # 执行 pte_addr = base + idx * ptesize
(gdb) print /x pte_addr
$55 = 0x80204ff8  // base + 0x1ff*8 = 当前L2页表项地址

(gdb) step  # 执行 pte = ldq_phys(...)
(gdb) print /x pte
$56 = 0x20xxxxxxxx  // 读出的L2级页表项内容

# 检查是否为叶子节点
(gdb) print /x (pte & 0xe)  // R|W|X位
$57 = 0xc  // 非零，有权限，这是叶子节点，break

(gdb) print /x (pte >> PTE_PPN_SHIFT)  // 物理页号
$58 = 0x80200  // 4K页的物理页号

# ========== 如果不是叶子，进入第二层循环（i=1, L1） ==========
# （此例中第一层已是叶子，所以不再演示）

# ========== 最终物理地址计算 ==========
(gdb) print /x *physical
$59 = 0x80200000  // ppn | (vpn_offset) << PGSHIFT
```

---

# 第四部分：QEMU中TLB查找源码与调试演示

## 4.1 TLB查找的源码位置

QEMU在 `accel/tcg/cputlb.c` 中实现了软件模拟的TLB：

```c
// 文件：accel/tcg/cputlb.c
// 函数：tlb_fill() 第878行
int tlb_fill(CPUState *cpu, target_ulong addr, int size,
             MMUAccessType access_type, int mmu_idx, 
             bool probe, uintptr_t retaddr)
{
    // 内部逻辑：
    // 1. 尝试从TLB查找
    // 2. TLB miss → 调用体系结构特定的tlb_fill函数
    //              (例如 riscv_cpu_tlb_fill)
    // 3. 该函数进行页表查找，写入TLB
    // 4. 返回是否成功
}

// 文件：accel/tcg/cputlb.c
// 函数：get_page_addr_code() 第1033行
static target_ulong get_page_addr_code(CPURISCVState *env,
                                       target_ulong addr)
{
    index = tlb_index(env, mmu_idx, addr);        // 计算TLB索引
    entry = tlb_entry(env, mmu_idx, addr);        // 获取TLB条目指针
    
    if (likely(entry->addr_code != -1 &&
               (addr & TARGET_PAGE_MASK) == 
               (entry->addr_code & TARGET_PAGE_MASK))) {
        // TLB hit：虚拟地址与TLB条目的tag匹配
        return entry->addr_code & TARGET_PAGE_MASK;  // 返回物理页
    } else {
        // TLB miss：调用tlb_fill进行页表查找
        tlb_fill(cpu, addr, 0, MMU_INST_FETCH, mmu_idx, false, retaddr);
        ...
    }
}
```

## 4.2 TLB查找的实际调用链（GDB调试得到）

从本次调试Session中观察到的真实调用栈：

```
get_physical_address() [accel/tcg/cputlb.c:252行，读PTE]
    ↑ Value returned is $44 = 536871119
riscv_cpu_tlb_fill() [target/riscv/cpu_helper.c:451行]
    ↑ ret = get_physical_address(...)
tlb_fill() [accel/tcg/cputlb.c:878行]
    ↑ ok = cc->tlb_fill(cpu, ...)
get_page_addr_code() [accel/tcg/cputlb.c:1033行]
    ↑ phys_pc = get_page_addr_code(desc.env, pc);
tb_htable_lookup() [accel/tcg/cpu-exec.c:339行]
    ↑ 查找translation block，需要虚拟地址对应的物理页
```

这个栈清晰地表明：首先get_page_addr_code()尝试获取指令对应的物理地址，若TLB miss，则逐级调用tlb_fill()和riscv_cpu_tlb_fill()，最后调用get_physical_address()进行页表查找。

## 4.3 TLB的内部数据结构

```c
// QEMU的TLB条目定义
typedef struct CPUTLBEntry {
    uint64_t addr_read;    // 读访问的虚拟地址tag
    uint64_t addr_write;   // 写访问的虚拟地址tag
    uint64_t addr_code;    // 取指的虚拟地址tag
    uint64_t addend;       // 物理地址加数：phys_addr = vaddr + addend
    // addend技巧：将虚拟地址直接加上addend就得到物理地址
} CPUTLBEntry;

// TLB查找的关键算法
target_ulong tlb_index(CPURISCVState *env, int mmu_idx, target_ulong addr)
{
    uintptr_t size_mask = env_tlb(env)->f[mmu_idx].mask >> CPU_TLB_ENTRY_BITS;
    return (addr >> TARGET_PAGE_BITS) & size_mask;
}

// TLB查找逻辑
CPUTLBEntry *entry = &tlb_table[mmu_idx][index];
if (entry->addr_code == (addr & TARGET_PAGE_MASK)) {
    // tag匹配，hit
    return phys_page;
} else {
    // tag不匹配，miss，调用tlb_fill
}
```

## 4.4 调试演示：观察TLB miss引发的页表查找

在Terminal 3中设置条件断点，捕捉SATP≠0的地址翻译：

```gdb
(gdb) delete 1
(gdb) b get_physical_address if env->satp != 0
Breakpoint 2 at 0x62746f64a55c

(gdb) c
Continuing.

Thread 3 "qemu-system-ris" hit Breakpoint 2, get_physical_address (
    env=0x627491b68ce0, physical=0x7caddd8c1d80, ...)
    at /mnt/c/Users/13081/qemu-4.1.1/target/riscv/cpu_helper.c:158
158 {
(gdb) print /x env->satp
$26 = 0x8000000000080204  // SATP非零，分页启用

(gdb) bt
#0  get_physical_address (...) at cpu_helper.c:158
#1  0x000062746f64b238 in riscv_cpu_tlb_fill (...)
    at cpu_helper.c:451
    // ← TLB miss时调用此函数
#2  0x000062746f59068f in tlb_fill (...)
    at cputlb.c:878
    // ← TLB管理框架
#3  0x000062746f59xxxx in get_page_addr_code (...)
    at cputlb.c:1033
    // ← 正在取指，查TLB，miss了
```

这个栈跟踪证明了TLB→tlb_fill→riscv_cpu_tlb_fill→get_physical_address的完整调用链。



