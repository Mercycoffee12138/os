# Lab6 Challenge 2: 调度算法分析报告

## 学号: 2310137

---

## 一、实现的调度算法

### 1. RR (Round Robin) 时间片轮转调度
**文件**: `kern/schedule/default_sched.c`

**算法描述**:
- 每个进程分配固定时间片(MAX_TIME_SLICE=5)
- 进程按FIFO顺序在就绪队列中排列
- 时间片用完后，进程被移到队尾，选择队首进程执行

**时间复杂度**: O(1)

**特点**:
| 优点 | 缺点 |
|------|------|
| 公平性好，每个进程平等获得CPU | 上下文切换开销大 |
| 响应时间短 | 不考虑进程优先级 |
| 实现简单 | 时间片大小难以选择 |

**适用场景**: 分时系统、交互式应用

---

### 2. Stride Scheduling 步进调度
**文件**: `kern/schedule/default_sched_stride.c`

**算法描述**:
- 每个进程有stride值和priority优先级
- 选择stride最小的进程运行
- 运行后stride += BIG_STRIDE / priority
- 优先级越高，stride增长越慢，获得CPU越多

**时间复杂度**: O(log n) (使用斜堆)

**关键公式**:
```
CPU分配比例 = priority_i / Σ priority
stride增量 = BIG_STRIDE / priority
```

**特点**:
| 优点 | 缺点 |
|------|------|
| 精确的比例分配CPU | 实现较复杂 |
| 支持优先级 | 需要维护优先级队列 |
| 确定性行为 | BIG_STRIDE选择需要考虑溢出 |

**适用场景**: 需要按比例分配CPU的系统、实时系统

---

### 3. FIFO (First In First Out) 先来先服务
**文件**: `kern/schedule/sched_FIFO.c`

**算法描述**:
- 按进程到达顺序排队
- 非抢占式：进程运行直到完成或阻塞
- 不使用时间片抢占

**时间复杂度**: O(1)

**特点**:
| 优点 | 缺点 |
|------|------|
| 实现最简单 | 护航效应(Convoy Effect) |
| 无上下文切换开销 | 平均等待时间可能很长 |
| 无饥饿问题 | 对短作业不友好 |

**护航效应示例**:
```
进程A(执行时间100ms) 先到达
进程B(执行时间1ms) 后到达

结果: B必须等待A完成，等待时间100ms
```

**适用场景**: 批处理系统、作业执行时间相近的场景

---

### 4. Priority Scheduling 优先级调度
**文件**: `kern/schedule/sched_priority.c`

**算法描述**:
- 按优先级排序，高优先级先执行
- 使用lab6_priority字段(值越大优先级越高)
- 抢占式：使用时间片

**时间复杂度**: O(n) (入队时排序)

**特点**:
| 优点 | 缺点 |
|------|------|
| 重要任务优先执行 | 可能导致饥饿 |
| 灵活性高 | 优先级反转问题 |
| 适合实时系统 | 需要合理设计优先级 |

**饥饿问题**:
```
高优先级进程持续到达 → 低优先级进程永远得不到执行
```

**解决方案**: 老化(Aging) - 随时间增加等待进程的优先级

**适用场景**: 实时系统、需要区分任务重要性的系统

---

## 二、性能指标比较

### 评价指标

1. **周转时间(Turnaround Time)**: 从提交到完成的总时间
2. **等待时间(Waiting Time)**: 在就绪队列中等待的时间
3. **响应时间(Response Time)**: 从提交到首次响应的时间
4. **CPU利用率(CPU Utilization)**: CPU工作时间比例
5. **吞吐量(Throughput)**: 单位时间完成的进程数
6. **公平性(Fairness)**: 各进程获得CPU时间的均衡程度

### 理论分析

| 算法 | 周转时间 | 等待时间 | 响应时间 | 公平性 | 吞吐量 |
|------|----------|----------|----------|--------|--------|
| RR | 中等 | 中等 | 短 | 高 | 中等 |
| Stride | 中等 | 按比例 | 短 | 高(加权) | 中等 |
| FIFO | 长(变化大) | 长 | 长 | 中等 | 较高 |
| Priority | 变化大 | 变化大 | 高优先级短 | 低 | 中等 |

### 测试场景分析

**场景1: 5个进程，不同优先级和工作量**
```
进程0: 优先级5, 工作量2  (高优先级短作业)
进程1: 优先级4, 工作量4  (中等)
进程2: 优先级3, 工作量3  (中等)
进程3: 优先级2, 工作量5  (低优先级长作业)
进程4: 优先级1, 工作量1  (最低优先级最短作业)
```

**预期完成顺序**:
- **RR**: 主要取决于工作量，约为 4→0→2→1→3
- **Stride**: 高优先级进程整体先完成，0→4→2→1→3
- **FIFO**: 按创建顺序，0→1→2→3→4
- **Priority**: 严格按优先级，0→1→2→3→4

---

## 三、如何切换调度算法

修改 `kern/schedule/sched.c` 第18行:

```c
#define SCHED_ALGORITHM 0  // RR调度器
#define SCHED_ALGORITHM 1  // Stride调度器
#define SCHED_ALGORITHM 2  // FIFO调度器
#define SCHED_ALGORITHM 3  // Priority调度器
```

然后重新编译:
```bash
make clean && make qemu
```

---

## 四、测试方法

### 使用priority测试程序
```bash
make run-priority
```

### 使用自定义测试程序
```bash
make run-sched_test
```

### 使用测试脚本比较所有算法
```bash
./tools/test_schedulers.sh all
```

---

## 五、总结与建议

### 算法选择建议

| 场景 | 推荐算法 | 原因 |
|------|----------|------|
| 交互式系统 | RR | 响应时间短，公平 |
| 批处理系统 | FIFO | 简单，无抢占开销 |
| 实时系统 | Priority | 关键任务优先 |
| 按比例分配 | Stride | 精确控制CPU分配 |
| 多媒体应用 | Stride | 保证QoS |

### 改进方向

1. **多级反馈队列(MLFQ)**: 结合RR和Priority的优点
2. **完全公平调度(CFS)**: Linux采用的调度算法
3. **老化机制**: 解决Priority调度的饥饿问题
4. **实时调度**: EDF(最早截止时间优先)、RMS(速率单调调度)

